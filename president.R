# Load up the data with
# pres.df <- presidentGrab()

presidentGrab <- function() {
  all.states <- as.list(c(state.abb, "US"))
  poll.full <- llply(all.states, stateDfGen, topic = "2012-president")
  df.out <- ldply(poll.full)
  return(df.out)
}

# we make a few assumptions about structure. Thankfully most
# of them stem from the structure we created w/ presidentGrab()

# pres.scratch is our working file for most of this. We don't want to 
# do anything TOO destructive to pres.df in case we need some info but
# we want to be able to quickly generate graphics 


#drop all NA columns (which would've been generated by the above subsetting
# pres.scratch <- pres.scratch[, colSums(is.na(pres.scratch)) < nrow(pres.scratch)]



# Drop some extraneous variables

varDrop <- function(data) {
  qualities <- c("id",
                 "pollster",
                 "avg_date",
                 "method",
                 "chart",
                 "state",
                 "subpopulation",
                 "observations",
                 "margin_of_error")
  # add avg date
  data[, "start_date"] <- as.Date(data[, "start_date"])
  data[, "end_date"] <- as.Date(data[, "end_date"])
  data <- ddply(data, c("start_date", "end_date"), 
                        transform, avg_date = end_date - difftime(end_date, start_date)/2)
  data <- data[, c(1, ncol(data), 2:(ncol(data) - 1))]
  browser()
  data[, c(qualities, names(data)[15:ncol(data)])]
}
pres.scratch <- varDrop(pres.df)




## DROP
## anything that drops rows goes here

# the topic parameter isn't very good at filtering
pres.scratch <- pres.scratch[grep("president|Obama|Romney|job-approval", pres.scratch[, "name"], ignore.case = TRUE), ]


### Drop based by row name
# Drop polls which are outlandishly far from 100%

constrainApproval <- function(data) {
  rownames(data) <- as.character(1:nrow(data))
  approval.chart <- unique(as.character(data[grep("job-approval", data[, "chart"]), "chart"]))
  outcome.names <- names(data)[grep("approve|mixed|undecided|neither", names(data), ignore.case = TRUE)]
  int.sum <- rowSums(data[data[, "chart"] %in% approval.chart, outcome.names], na.rm = TRUE)
  range.drop <- names(int.sum[int.sum > 110 | int.sum < 80])
  # resulting rownames() have gaps
  data[!rownames(data) %in% range.drop, ]
}
pres.scratch <- constrainApproval(pres.scratch)



# Anything before the start of the year goes.


pres.scratch <- pres.scratch[pres.scratch[, "avg_date"] > as.Date("2012-01-01"), ]
# some polls don't indicate a date (this will improve as this package gets better
# at detecting them) and aren't all that helpful
# eventually we'll assign a guess based on id interpolation (german tank problem!)
pres.scratch <- pres.scratch[!is.na(pres.scratch[, "avg_date"]), ]


# Regenerate rownames after dropping
# see http://kbroman.wordpress.com/2012/03/21/row-names-in-data-frames-beware-of-1nrow/

rownames(pres.scratch) <- as.character(1:nrow(pres.scratch))

## RELEVEL
## Anything that changes factor levels goes here

# Easier to consider "mixed" polls as at least partially automated
pres.scratch[pres.scratch[, "method"] == "Mixed", "method"] <- "Automated Phone"

# If it changes the factor level, make sure it is in fact.cols
fact.cols <- c("id", "pollster", "state", "method", "chart", "subpopulation")

# Convert to character first to remove factors associated w/ 0 rows
# relevel w/ lapply and assign to original columns
pres.scratch[, fact.cols] <- as.character(unlist(pres.scratch[, fact.cols]))
pres.scratch[, fact.cols] <- llply(pres.scratch[, fact.cols], as.factor)

## CONVERSION
## e.g. factor to numeric, etc.

pres.scratch[, "source"] <- as.character(pres.scratch[, "source"])
# Simpler to mass-reclass columns here on one df

## commented out as it generates a huge number of erroneous NAs
# pres.scratch[, 8:ncol(pres.scratch)] <- laply(pres.scratch[, 8:ncol(pres.scratch)], function(x) as.numeric(as.character(x)))



## REIFY
## convert "approve, don't approve, etc" to some value for Obama and Romney

# "obama-job-approval" is coded into "Disapprove"/"Approve"/"Undecided"
# job approval by state is coded more expansively



# catAppVariants <- function(data) {
#   approval.chart <- unique(as.character(data[grep("job-approval", data[, "chart"]), "chart"]))
#   app.index <- data[, "chart"] %in% approval.chart
#   # group coding for approval, etc.
#   approve.names <- names(data)[grep("[^dis]approve|^approve", names(data), ignore.case = TRUE)]
#   disapprove.names <- names(data)[grep("disappp?rove", names(data), ignore.case = TRUE)]
#   neutral.names <- names(data)[grep("mixed|undecided|neither", names(data), ignore.case = TRUE)]
#   # create and fill columns
#   data[, "Sum.Job.Neutral"] <- data[, "Sum.Job.Disapprove"] <- data[, "Sum.Job.Approve"] <- NA
#   synth.cols <- c("Sum.Job.Neutral", "Sum.Job.Disapprove", "Sum.Job.Approve")
#   data[app.index, synth.cols] <- lapply(list(neutral.names,
#                                     disapprove.names,
#                                     approve.names), 
#                                function(x) rowSums(data[app.index, x], na.rm = TRUE))
#   
#   # group codes for "not voting" etc.
#   vote.names <- names(data)[grep("vot|refused", names(data), ignore.case = TRUE)]
#   data[, "Non.Response"] <- NA
#   data[, "Non.Response"] <- rowSums(data[, vote.names], na.rm = TRUE)
#   #group codes for "other"
#   data[, "Other"] <- rowSums(data[, c("Other", "Depends")], na.rm = TRUE)
#   
#   #drop columns
#   keep.cols <- names(data)[!names(data) %in% c(approve.names, disapprove.names,
#                                                neutral.names, vote.names,
#                                                "Depends", "Johnson")]
#   data[data == 0] <- NA
#   data <- data[, keep.cols]
#   return(data)
# }
# pres.out <- catAppVariants(pres.scratch)
  
  
